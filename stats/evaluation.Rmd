---
title: "R Notebook"
output: html_notebook
---
First, we read the descriptions, stats, annotators, and embeddings data.
```{r}
descriptions <- read.table("descriptions.csv", sep = '\t', header= TRUE, encoding = "utf-8")
literal_stats <- read.table("literal_stats.csv", sep = '\t', header= TRUE)[1:31]
sentimental_stats <- read.table("sentimental_stats.csv", sep = '\t', header= TRUE)[1:31]
annotators <- read.table("annotators.csv", sep = '\t', header= TRUE, encoding = "utf-8")
embeddings <- read.table("embeddings.csv", sep = '\t', header= TRUE, encoding = "utf-8", row.names = 1)

```

Next, we define plot color spaces and sizes.
```{r}
library(colorspace)
coul <- c("#FFC20A","#0C7BDC","#A72608","#134611")
fill <- adjustcolor(coul,alpha=0.8)
bord <- sapply(sapply(coul, darken), darken)
library(RColorBrewer)
barPal <- brewer.pal(12,"Set3")
barPalBord <- sapply(sapply(barPal, darken), darken)

# These 16 colors are taken from https://sashamaps.net/docs/resources/20-colors/, with an accessibility of 99% and excluding black / white.
coul_16 <- c('#e6194B', 
             '#3cb44b', 
             '#ffe119', 
             '#4363d8', 
             '#f58231', 
             '#42d4f4', 
             '#f032e6', 
             '#fabed4', 
             '#469990', 
             '#dcbeff', 
             '#9A6324', 
             '#fffac8', 
             '#800000', 
             '#aaffc3', 
             '#000075', 
             '#a9a9a9')
coul_16_Bord <- sapply(sapply(coul_16, darken), darken)

titleSize <- 2.5
axisLabelSize <- 2.5
labelSize <- 3
legendLabelSize <- 2.5
plotMargins <- c(6,9,12,4) + 0.1
```

This section pretransforms our dataframes and assigns column names

```{r}
stat_columns = c("variable","t","p_t-test","c","p_correlation") 
stat_columns_comp = c("variable",
                      "variable_comp",
                      "t-test_literal",
                      "p_t-test_literal",
                      "correlation_literal",
                      "p_correlation_literal",
                      "t-test_sentimental",
                      "p_t-test_sentimental",
                      "correlation_sentimental",
                      "p_correlation_sentimental")
summary_names = c("Min","Q1","Median","Mean","Q3","Max","SD","Var")
literal_names = paste(summary_names, "_literal", sep="")
sentimental_names = paste(summary_names, "_sentimental", sep="")

modes = c("literal","sentimental")

all_columns <- append(stat_columns,c(literal_names,sentimental_names,summary_names),1)

annotator_vars <- names(annotators)[4:15]
annotator_vars_numeric <- names(annotators)[c(4,11,12,13)]
annotator_vars_nonNumeric <- names(annotators)[c(5,6,7,8,9,10,14,15)]
annotator_stats <- data.frame()
description_vars <- c("spelling_errors",
                      "sentiment",
                      names(literal_stats)[3:31], 
                      annotator_vars_numeric, 
                      names(descriptions)[8])

literal_stats$mode <- "literal"
sentimental_stats$mode <- "sentimental"

literal_stats$annotator <- descriptions$annotator[descriptions$X_id==literal_stats$X_id]
sentimental_stats$annotator <- descriptions$annotator[descriptions$X_id==sentimental_stats$X_id]

library(lubridate, warn.conflicts = FALSE)

literal_stats$timeTaken <- as.numeric(as.duration(hms(descriptions$timeTaken[descriptions$X_id==literal_stats$X_id])))
sentimental_stats$timeTaken <- as.numeric(as.duration(hms(descriptions$timeTaken[descriptions$X_id==sentimental_stats$X_id])))

# Set description times over 10 minutes to the mean description time
literal_stats$timeTaken[literal_stats$timeTaken>600] <- mean(literal_stats$timeTaken[literal_stats$timeTaken<=600])
sentimental_stats$timeTaken[sentimental_stats$timeTaken>600] <- mean(sentimental_stats$timeTaken[sentimental_stats$timeTaken<=600])

literal_stats$spelling_errors <- descriptions$literal_spelling_errors[descriptions$X_id==literal_stats$X_id]
sentimental_stats$spelling_errors <- descriptions$sentimental_spelling_errors[descriptions$X_id==sentimental_stats$X_id]

literal_stats$sentiment <- descriptions$literal_sentiment[descriptions$X_id==literal_stats$X_id]
sentimental_stats$sentiment <- descriptions$sentimental_sentiment[descriptions$X_id==sentimental_stats$X_id]

for (annotator_var in annotator_vars){
  literal_stats[annotator_var] <- annotators[,annotator_var][match(literal_stats$annotator,annotators$X_id)]
  sentimental_stats[annotator_var] <- annotators[,annotator_var][match(sentimental_stats$annotator,annotators$X_id)]
}

joined_stats <- rbind(literal_stats, sentimental_stats)


mode_colors  <-  ifelse(joined_stats$mode == "literal", coul[2], coul[1])
mode_shapes  <-  ifelse(joined_stats$mode == "literal", 15, 19)
```

```{r}
modePanel <- function (x, y, col = par("col"), bg = NA, pch = par("pch"), 
    cex = 1, col.smooth = 2, span = 2/3, iter = 3, ...) 
{
    points(x, y, pch = pch, col = col, bg = bg, cex = cex, xlab = names(x), ylab = names(y))
    ok <- is.finite(x) & is.finite(y)
    
    # Plot smoothing lines if there is at least a weak correlation (r>0.3)
    if((abs(c_literal$estimate)>0.3)||(abs(c_literal$estimate)>0.3)){
      literalLineIndices <- Reduce(intersect, list(which(joined_stats$mode=="literal"), which(ok)))
      lines(lowess(data.frame(x[literalLineIndices],
                            y[literalLineIndices], f=3)),
                            col = "black", lty = 2, lwd = 3)
      sentimentalLineIndices <- Reduce(intersect, list(which(joined_stats$mode=="sentimental"), which(ok)))
      lines(lowess(data.frame(x[sentimentalLineIndices],
                            y[sentimentalLineIndices], f=3)),
                            col = "black", lty=3, lwd = 3)
    }
}
```


Assumptions for pearson's correlation, inspired by Cohen(1988):

|correlation coefficient value|strength of correlation|
|:----------------------------|:----------------------|
|0.3 < \| r \| <= .5          |weak                   |
|0.5 < \| r \| <= .7          |moderate               |
|0.7 < \| r \| <= 1           |strong                 |

```{r}
t_tests <- data.frame(matrix(nrow=0, ncol = length(all_columns)))
t_tests_comp <- data.frame(matrix(nrow=0, ncol = 6))

for (title in description_vars){
  literalVariableName <- sprintf("%s_literal", title)
  sentimentalVariableName <- sprintf("%s_sentimental", title)
  literalColumn <- literal_stats[,title]
  sentimentalColumn <- sentimental_stats[,title]

  if(!title %in% annotator_vars_numeric&&title!="timeTaken"){
  png(sprintf("plots/%s.png",title), 1200, 1200, type = 'cairo')
  par(mar=plotMargins) 
  boxplot(round(literalColumn,2), round(sentimentalColumn, 2),
    main = sprintf("%s, literal vs. sentimental descriptions", title),
    names = c("literal","sentimental"),
    col = coul,
    bg=coul,
    pch=21,
    border = bord,
    cex.axis = axisLabelSize,
    cex.main = titleSize)
  text(x=1.5, y=fivenum(round(literalColumn,2)),labels=fivenum(round(literalColumn,1)), cex = 0.8 * axisLabelSize)
  text(x=2.5, y=fivenum(round(sentimentalColumn, 2)),labels=fivenum(round(sentimentalColumn, 1)), cex = 0.8 * axisLabelSize)
  title(xlab = "description mode", ylab = title, cex.lab = labelSize, line = 4.5)
  dev.off()
  t <- t.test(literalColumn, sentimentalColumn)
  c <- cor.test(literalColumn, sentimentalColumn)
  summary_literal <- c(summary(literalColumn),sd(literalColumn),var(literalColumn))
  summary_sentimental <- c(summary(sentimentalColumn),sd(sentimentalColumn),var(sentimentalColumn))
  summary_joint <- c(summary(joined_stats[,title]),sd(joined_stats[,title]),var(joined_stats[,title]))

  names(summary_literal)=literal_names
  names(summary_sentimental)=sentimental_names
  names(summary_joint)=summary_names

  stat_vector = c(title,t$statistic,t$p.value,c$estimate,c$p.value)
  stat_vector <- append(stat_vector,c(summary_literal,summary_sentimental,summary_joint),1)
  names(stat_vector)  <-  all_columns

  t_tests <- rbind(t_tests, stat_vector)
  
  }
  for (title_comp in description_vars){
    if (title == title_comp) {
      next
    }
    literalColumn_comp <- literal_stats[,title_comp]
    sentimentalColumn_comp <- sentimental_stats[,title_comp]
    t_literal <- t.test(literalColumn, literalColumn_comp)
    c_literal <- cor.test(literalColumn, literalColumn_comp)

    t_sentimental <- t.test(sentimentalColumn, sentimentalColumn_comp)
    c_sentimental <- cor.test(sentimentalColumn, sentimentalColumn_comp)
    stat_vector_comp = c(title, title_comp,
                         t_literal$statistic, t_literal$p.value, c_literal$estimate, c_literal$p.value,
                         t_sentimental$statistic, t_sentimental$p.value, c_sentimental$estimate, c_sentimental$p.value)
    names(stat_vector_comp) <- stat_columns_comp
    
    t_tests_comp <- rbind(t_tests_comp, stat_vector_comp)
    colnames(t_tests_comp) <- stat_columns_comp

    if(any(t_tests_comp$variable == title_comp & t_tests_comp$variable_comp == title)){
      next
    }    
    png(sprintf("plots/%s_vs_%s.png",title,title_comp), 1200, 1200, type = 'cairo')
    par(mar=plotMargins) 
    pairs(data.frame(joined_stats[title],joined_stats[title_comp]),
      col = mode_colors,
      pch=mode_shapes,
      cex=1.5,
      las=1,
      cex.axis = axisLabelSize,
      cex.main = titleSize,
      cex.labels = labelSize,
      panel = modePanel,
      oma=plotMargins)
    
    title(main = sprintf("%s vs. %s", title, title_comp), cex.main=titleSize, line = 6.5)

    if((abs(c_literal$estimate)>0.3)||(abs(c_literal$estimate)>0.3)){
      legendLevels <- levels(factor(joined_stats$mode))
      legendLevels[1] <- sprintf("%s, r = %.2f",legendLevels[1],c_literal$estimate)
      legendLevels[2] <- sprintf("%s, r = %.2f",legendLevels[2],c_sentimental$estimate)
      
      legend("center",
      legend = legendLevels,
      pch = c(15,19),
      cex=legendLabelSize,
      pt.cex = 3,
      col = c(coul[2], coul[1]),
      text.col = "white",
      text.width = 1.5 * legendLabelSize * strwidth(legendLevels)[1])
      
      legend("center",
      legend = legendLevels,
      cex=legendLabelSize,
      pt.cex = 3,
      col = "black",
      lty = c(2,3),
      lwd = 3,
      bty="n",
      text.col = "black",
      text.width = 1.5 * legendLabelSize * strwidth(legendLevels)[1]
      )
      

    }else{
      legend("center",
      legend = levels(factor(joined_stats$mode)),
      pch = c(15,19),
      cex=legendLabelSize,
      col = c(coul[2], coul[1]))
    }
    dev.off()
  }
}
# Special treatment for timings since we've recorded them independent of the description mode.
png("plots/timeTaken.png", 1000, 1000, type = 'cairo')
par(mar=plotMargins) 
boxplot(round(literal_stats$timeTaken,1),
    main = "timeTaken",
    ylab = "timeTaken (seconds)",
    col = coul,
    bg=coul,
    border = bord,
    cex.axis = axisLabelSize,
    cex.main = titleSize,
    cex.lab = labelSize)
  text(x=1.25, y=fivenum(round(literal_stats$timeTaken,1)),labels=fivenum(round(literal_stats$timeTaken,1)), font=2, cex = 0.8 * axisLabelSize)
dev.off()

colnames(t_tests)=all_columns
colnames(t_tests_comp) <- stat_columns_comp
write.csv(t_tests,"surfaceStats.csv", row.names=FALSE)
write.csv(t_tests_comp,"surfaceStats_comp.csv", row.names=FALSE)
```


```{r}
annotators$firstLanguage<-replace(annotators$firstLanguage, annotators$firstLanguage%in%c("de","deutsch","Deutsch"), "DE")
annotators$firstLanguage<-replace(annotators$firstLanguage, annotators$firstLanguage=="portugiesisch", "PT")
annotators$firstLanguage<-replace(annotators$firstLanguage, annotators$firstLanguage=="Arabisch", "AR")

annotators$nationality<-replace(annotators$nationality, annotators$nationality%in%c("de","deutsch","Deutsch"), "DE")
annotators$nationality<-replace(annotators$nationality, annotators$nationality=="Israelisch", "IL")
annotators$nationality<-replace(annotators$nationality, annotators$nationality=="Ã–sterreichisch", "AT")

annotators$lineOfWork<-replace(annotators$lineOfWork, annotators$lineOfWork=="it", "IT")


for (title in annotator_vars_numeric){
  column <- annotators[,title]
  png(sprintf("plots/%s.png",title), 600, 600, type = 'cairo')
  par(mar=c(2,5,4,2) + 0.1) 
  boxplot(column,
    main = sprintf("%s distribution", title),
    ylab = title,
    col = coul,
    bg=coul,
    pch=21,
    border = bord,
    cex.axis = 2.0,
    cex.main = 2.5,
    cex.lab = 2.0)
  text(x=1.3, y=fivenum(column),labels=fivenum(column), cex=1.5, font=2)
  dev.off()
  summary <- summary(column)
  annotator_stats <- rbind(annotator_stats, summary)
}

library("plyr")
for (title in annotator_vars_nonNumeric){
  column <- annotators[,title]
  max <- round_any(max(matrix(table(column))[,1]), 5, f = ceiling) 
  png(sprintf("plots/%s.png",title), 1000, 650, type = 'cairo')
  par(mar=c(5,30,4,2) + 0.1) # Add space to left margin.
  barplot(table(column)[order(table(column),decreasing = TRUE)],
    horiz = TRUE,
    xaxt = "n",
    las=2,
    main = title,
    col = barPal,
    bg= barPal,
    bord=barPalBord,
    xlim = c(0, max),
    cex.axis = 2.5,
    cex.lab = 2.5,
    cex.main = 2.5,
    cex.names = 1.8
  )
  axis(1, at = seq(0, max,  1),labels=NA, cex.axis = 2.0)
  axis(1, at = seq(0, max,  5), lwd=3, cex.axis = 2.0)
  par(mar=c(5,4,4,2) + 0.1) # Restore default spacing
  dev.off()
}
```

Next, we're evaluating the automatic tag generation:
```{r}
library(readr)
models <- read_delim("models.csv", delim = "\t", escape_double = FALSE, trim_ws = TRUE, show_col_types = FALSE)
models$autoTags <- strsplit(models$autoTags, ",")
models$tags <- strsplit(models$tags, ",")
models[c("autoTags_TP","autoTags_FP","autoTags_FN","autoTags_TN",
         "autoTags_total","autoTags_accuracy",
         "autoTags_P","autoTags_R","autoTags_F1")] <- 0
for(i in 1:nrow(models)){
  cat <- models[i, ]$category
  autoTags <- unlist(models[i, ]$autoTags)
  autoTags <- data.frame(t(sapply(strsplit(autoTags, ":"),c)))
  names(autoTags) <- c("tag","conf")
  
  autoTags$conf <- as.numeric(autoTags$conf)
  autoTags <- autoTags[autoTags$conf>10,]
  tags <- unlist(models[i, ]$tags)
  # True Positives: predicted tags that are in the manual tag list, equal to the category name, or have above 90% confidence.
  models[i,]$autoTags_TP <- length(which(autoTags$tag%in%tags | autoTags$tag==cat | autoTags$conf>=90))
  # False Positives: predicted tags that are not in the manual tag list, inequal to the category name, and have between 80% and 90% confidence.
  models[i,]$autoTags_FP <- length(which(!autoTags$tag%in%tags & autoTags$tag!=cat & autoTags$conf<90 & autoTags$conf >=80))
  # False Negatives: manual tags and category names that are not in the predicted tag list.
  models[i,]$autoTags_FN <- length(which(c(!tags%in%autoTags$tag, !cat%in%autoTags$tag)))
  # True Negatives: predicted tags that are not in the manual tag list, inequal to the category name, and have below 50% confidence. 
  models[i,]$autoTags_TN <- length(which(!autoTags$tag%in%tags & autoTags$tag!=cat & autoTags$conf<50))
  models[i,]$autoTags_total <- models[i,]$autoTags_TP+models[i,]$autoTags_FP+models[i,]$autoTags_FN+models[i,]$autoTags_TN
  models[i,]$autoTags_accuracy <- (models[i,]$autoTags_TP+models[i,]$autoTags_TN)/models[i,]$autoTags_total
  models[i,]$autoTags_P <- models[i,]$autoTags_TP / (models[i,]$autoTags_TP + models[i,]$autoTags_FP)
  models[i,]$autoTags_R <- models[i,]$autoTags_TP / (models[i,]$autoTags_TP + models[i,]$autoTags_FN)
  models[i,]$autoTags_F1 <- 2 * models[i,]$autoTags_P * models[i,]$autoTags_R / (models[i,]$autoTags_P + models[i,]$autoTags_R)
}

tp_total <- sum(models$autoTags_TP)
fp_total <- sum(models$autoTags_FP)
fn_total <- sum(models$autoTags_FN)
tn_total <- sum(models$autoTags_TN)
total <- sum(models$autoTags_total)
accuracy_total <- (tp_total+tn_total) / total
p_total <- tp_total / (tp_total + fp_total)
r_total <- tp_total / (tp_total + fn_total)
f1_total <- 2 * p_total * r_total / (p_total + r_total)


# Plot accuracy / F1 distributions over all categories
png("plots/autoTags_accuracy_vs_F1.png", 800, 800, type = 'cairo')
boxplot(round(models$autoTags_accuracy,2), round(models$autoTags_F1, 2),
    main = "autoTags, accuracy vs. F1-score",
    names = c("accuracy","F1-score"),
    ylim = c(0,1),
    col = coul,
    bg=coul,
    pch=21,
    border = bord,
    cex.axis = 1.5,
    cex.main = 1.5,
    cex.lab = 1.5)
  text(x=1.5, y=fivenum(round(models$autoTags_accuracy,2)),labels=fivenum(round(models$autoTags_accuracy,2)), font=2)
  text(x=2.5, y=fivenum(round(models$autoTags_F1, 2)),labels=fivenum(round(models$autoTags_F1, 2)), font=2)
  dev.off()

# Plot Precision / Recall distribution over all categories 
png("plots/autoTags_precision_vs_recall.png", 1000, 1000, type = 'cairo')
par(mar=c(5,6,4,2) + 0.1)
plot(round(models$autoTags_P,2), round(models$autoTags_R, 2),
    main = "autoTags, precision vs. recall",
    names = c("P","R"),
    xlab = "P",
    ylab = "R",
    xlim = c(0,1),
    ylim = c(0,1),
    col=factor(models$category),
    pch = c(15,17,19),
    cex.axis = 2.5,
    cex.main = 3,
    cex.lab = 2.5,
    cex=2)

lines(lowess(data.frame(models$autoTags_P, models$autoTags_R, f=2)), col = "black", lty = 5, lwd = 3)

legend("bottomright",
       legend = levels(factor(models$category)),
       pch = c(15,17,19),
       cex=2,
       col=factor(levels(factor(models$category))))
par(mar=c(5,4,4,2) + 0.1)
dev.off() 


# Plot Precision distribution by category 
png("plots/autoTags_precision_vs_category.png", 1000, 1000, type = 'cairo')
par(mar=c(8,15,4,2) + 0.1)
boxplot(round(models$autoTags_P,2) ~ models$category,
    main = "autoTags, precision by category",
    horizontal = TRUE,
    ylim=c(0,1),
    xlab=NA,
    ylab=NA,
    las = 2,
    xaxt = "n",
    col = coul_16,
    bg = coul_16,
    border = coul_16_Bord,
    cex.axis = 2.0,
    cex.main = 3)
axis(1, at = seq(0, 1,  1/10), cex.axis = 2.0)
grid(ny=NA, col = adjustcolor("black", alpha=0.3), lty = 2, lwd = 1)
title(xlab = "Precision", cex.lab = 2, line = 4.5)
dev.off()

# Plot Recall distribution by category 
png("plots/autoTags_recall_vs_category.png", 1000, 1000, type = 'cairo')
par(mar=c(8,15,4,2) + 0.1)
boxplot(round(models$autoTags_R,2) ~ models$category,
    main = "autoTags, recall by category",
    horizontal = TRUE,
    ylim=c(0,1),
    xlab=NA,
    ylab=NA,
    las = 2,
    xaxt = "n",
    col = coul_16,
    bg= coul_16,
    border = coul_16_Bord,
    cex.axis = 2.0,
    cex.main = 3)

axis(1, at = seq(0, 1,  1/10), cex.axis = 2.0)
grid(ny=NA, col = adjustcolor("black", alpha=0.3), lty = 2, lwd = 1)
title(xlab = "Recall", cex.lab = 2, line = 4.5)
dev.off()

# Plot F1 distribution by category 
png("plots/autoTags_f1_vs_category.png", 1000, 1000, type = 'cairo')
par(mar=c(8,15,4,2) + 0.1)
boxplot(round(models$autoTags_F1,2) ~ models$category,
    main = "autoTags, F1-score by category",
    horizontal = TRUE,
    ylim=c(0,1),
    xlab=NA,
    ylab=NA,
    las = 2,
    xaxt = "n",
    col = coul_16,
    bg= coul_16,
    border = coul_16_Bord,
    cex.axis = 2.0,
    cex.main = 3)

axis(1, at = seq(0, 1,  1/10), cex.axis = 2.0)
grid(ny=NA, col = adjustcolor("black", alpha=0.3), lty = 2, lwd = 1)
title(xlab = "F1-score", cex.lab = 2, line = 4.5)
dev.off()

cols <- c("cat1", "cat2", 
          "precision_mean_cat1", "precision_mean_cat2",
          "recall_mean_cat1", "recall_mean_cat2",
          "f1_mean_cat1", "f1_mean_cat2",
          "precision_t", "precision_p(t)",
          "recall_t", "recall_p(t)",
          "f1_t", "f1_p(t)")
t_tests <- data.frame(matrix(nrow=0, ncol = length(cols)))
names(t_tests) <- cols

for(i in 1:length(levels(factor(models$category)))){
  var <- levels(factor(models$category))[i]
  other_vars <- levels(factor(models$category))[-i]
  for(j in 1: length(other_vars)){
    other_var <- other_vars[j]
    cat1 <- models$category==var
    cat2 <- models$category==other_var
    precision_mean1 <-  mean(models$autoTags_P[cat1])
    precision_mean2 <-  mean(models$autoTags_P[cat2])
    precision_t <- t.test(models$autoTags_P[cat1], models$autoTags_P[cat2])

    recall_mean1 <-  mean(models$autoTags_R[cat1])
    recall_mean2 <-  mean(models$autoTags_R[cat2])
    recall_t <- t.test(models$autoTags_R[cat1], models$autoTags_R[cat2])

    f1_mean1 <-  mean(models$autoTags_F1[cat1])
    f1_mean2 <-  mean(models$autoTags_F1[cat2])
    f1_t <- t.test(models$autoTags_F1[cat1], models$autoTags_F1[cat2])

    stat_vector = c(var, other_var,
                    precision_mean1, precision_mean2,
                    precision_t$statistic, precision_t$p.value,
                    recall_mean1, recall_mean2,
                    recall_t$statistic, recall_t$p.value,
                    f1_mean1, f1_mean2,
                    f1_t$statistic, f1_t$p.value)
    names(stat_vector)  <-  cols
    t_tests <- rbind(t_tests, stat_vector)
  }
}
names(t_tests) <- cols
write.csv(t_tests,"autoTagsEvaluation.csv", row.names=FALSE)

```
```{r}
library(magrittr)
library(dplyr)
library(ggpubr)

categories <- c("bed", "bench", "cabinet", "chair", "chest", "couch", "decoration", "desk", "diningtable", "electronics", "hobby", "shelf", "stool", "tableware", "wardrobe")

dim_names <- c("Dim.1", "Dim.2")

# Create embeddings subsets
category_embeddings <- embeddings[endsWith(rownames(embeddings), "category"),]
image_embeddings <- embeddings[endsWith(rownames(embeddings), ".png"),]
literal_embeddings <- embeddings[grepl("literal",rownames(embeddings), fixed = TRUE),]
sentimental_embeddings <- embeddings[grepl("sentimental",rownames(embeddings), fixed = TRUE),]
```
Compute euclidean distance and cosine dissimilarity matrices, then apply multidimensional scaling. This step takes a few minutes.
```{r}
embeddings_dist_eucl <- dist(embeddings)

embeddings_matrix <- as.matrix(embeddings)
embeddings_sim <- embeddings_matrix / sqrt(rowSums(embeddings_matrix * embeddings_matrix))
embeddings_sim <- embeddings_sim %*% t(embeddings_sim)
embeddings_dist_cos <- as.dist(1 - embeddings_sim)

# Apply Multidimensional Scaling (MDS)
total_mds_eucl <-  as.data.frame(cmdscale(embeddings_dist_eucl))
total_mds_cos <-  as.data.frame(cmdscale(embeddings_dist_cos))

colnames(total_mds_eucl) <- dim_names
colnames(total_mds_cos) <- dim_names
```


```{r}
total_mds_eucl$category <- sub("-.*", "",sub("_.*", "", rownames(total_mds_eucl)))
total_mds_eucl$type[endsWith(rownames(total_mds_eucl), "category")] <- "category"
total_mds_eucl$type[grepl("literal",rownames(total_mds_eucl), fixed = TRUE)] <- "literal"
total_mds_eucl$type[grepl("sentimental",rownames(total_mds_eucl), fixed = TRUE)] <- "sentimental"
total_mds_eucl$type[endsWith(rownames(total_mds_eucl), ".png")] <- "image"

category_mds_eucl <- total_mds_eucl[total_mds_eucl$type=="category",]
literal_mds_eucl <- total_mds_eucl[total_mds_eucl$type=="literal",]
sentimental_mds_eucl <- total_mds_eucl[total_mds_eucl$type=="sentimental",]
image_mds_eucl <- total_mds_eucl[total_mds_eucl$type=="image",]


total_mds_cos$category <- sub("-.*", "",sub("_.*", "", rownames(total_mds_cos)))
total_mds_cos$type[endsWith(rownames(total_mds_cos), "category")] <- "category"
total_mds_cos$type[grepl("literal",rownames(total_mds_cos), fixed = TRUE)] <- "literal"
total_mds_cos$type[grepl("sentimental",rownames(total_mds_cos), fixed = TRUE)] <- "sentimental"
total_mds_cos$type[endsWith(rownames(total_mds_cos), ".png")] <- "image"

category_mds_cos <- total_mds_cos[total_mds_cos$type=="category",]
literal_mds_cos <- total_mds_cos[total_mds_cos$type=="literal",]
sentimental_mds_cos <- total_mds_cos[total_mds_cos$type=="sentimental",]
image_mds_cos <- total_mds_cos[total_mds_cos$type=="image",]
```

```{r}
# K-means clustering
image_clust_eucl <- kmeans(image_mds_eucl[,1:2], length(categories))$cluster %>% as.factor()
literal_clust_eucl <- kmeans(literal_mds_eucl[,1:2], length(categories))$cluster %>% as.factor()
sentimental_clust_eucl <- kmeans(sentimental_mds_eucl[,1:2], length(categories))$cluster %>% as.factor()
descr_clust_eucl <- kmeans(rbind(literal_mds_eucl[,1:2],sentimental_mds_eucl[,1:2]), length(categories))$cluster %>% as.factor()

image_clust_cos <- kmeans(image_mds_cos[,1:2], length(categories))$cluster %>% as.factor()
literal_clust_cos <- kmeans(literal_mds_cos[,1:2], length(categories))$cluster %>% as.factor()
sentimental_clust_cos <- kmeans(sentimental_mds_cos[,1:2], length(categories))$cluster %>% as.factor()
descr_clust_cos <- kmeans(rbind(literal_mds_cos[,1:2],sentimental_mds_cos[,1:2]), length(categories))$cluster %>% as.factor()


# Assign cluster groups to MDS matrices 
category_mds_eucl <- category_mds_eucl %>% mutate(group = 1:length(categories))
image_mds_eucl <- image_mds_eucl %>% mutate(group = image_clust_eucl)
literal_mds_eucl <- literal_mds_eucl %>% mutate(group = literal_clust_eucl)
sentimental_mds_eucl <- sentimental_mds_eucl %>% mutate(group = sentimental_clust_eucl)
descr_mds_eucl <- rbind(literal_mds_eucl,sentimental_mds_eucl) %>% mutate(group = descr_clust_eucl)


category_mds_cos <- category_mds_cos %>% mutate(group = 1:length(categories))
image_mds_cos <- image_mds_cos %>% mutate(group = image_clust_cos)
literal_mds_cos <- literal_mds_cos %>% mutate(group = literal_clust_cos)
sentimental_mds_cos <- sentimental_mds_cos %>% mutate(group = sentimental_clust_cos)
descr_mds_cos <- rbind(literal_mds_cos, sentimental_mds_cos) %>% mutate(group = descr_clust_cos)

```

Plot Description embeddings with base R:

```{r}
# To plot the descriptions using base R, use the following code:
png("plots/embeddings_mds_eucl_descriptions.png", 1400, 1400, type = 'cairo')
par(xpd = T, mar=c(8,15,4,10) + 0.1)
plot(literal_mds_eucl$Dim.1,literal_mds_eucl$Dim.2,
       col = coul[2],
       pch=19,
       cex=1.5,
       las=1,
       xlim=c(-11,-6.5),
       ylim=c(-1,1),
       cex.axis = axisLabelSize,
       cex.main = titleSize,
     ellipse=TRUE)

points(sentimental_mds_eucl$Dim.1,sentimental_mds_eucl$Dim.2,
       col = coul[1],
       pch=19,
       cex=1.5,
       las=1,
       cex.axis = axisLabelSize,
       cex.main = titleSize)

points(category_mds_eucl$Dim.1,category_mds_eucl$Dim.2,
       col = "black",
       bg = coul_16,
       lwd = 4,
       pch=23,
       cex=6,
       las=1,
       cex.axis = axisLabelSize,
       cex.main = titleSize)

legend("topright",
    legend = categories,
    pch = 24,
    cex=legendLabelSize,
    pt.cex = 4,
    pt.lwd = 3,
    col = "black",
    pt.bg = coul_16,
    text.col = "black")
par(mar=c(5, 4, 4, 2) + 0.1)
dev.off()
```

Plot Description embeddings with ggplot2.
The plots generated with ggplot2 are a bit less complicated to set up than the base R plots, but the legend currently doesn't include category points.
```{r}
library(ggpubr)

# description embeddings by mode, MDS based on cosine dissimilarity
png("plots/embeddings_mds_cos_descriptions_mode.png", 1400, 1400, type = 'cairo')
ggscatter(
     descr_mds_cos, x="Dim.1", y="Dim.2",
     palette = c(coul[2],coul[1]),
     ellipse = TRUE,
     size = 4,  
     legend = "bottomright", 
     ggtheme = theme_bw(),
     color = "type",
     alpha=0.75,
     font.tickslab = c(axisLabelSize*12, "plain"),
     font.x = c(axisLabelSize*16, "plain"),
     font.y = c(axisLabelSize*16, "plain"),
     font.title = c(titleSize*22, "bold"),
     font.subtitle = c(titleSize*14, "plain"),
     font.legend = c(axisLabelSize*16, "plain"),
     cex.main = titleSize
) + stat_mean(aes(fill=type),
     size=10,
     shape=21, 
     stroke = 1,
     color="black",
     alpha=0.5) + 
  geom_point(category_mds_cos,
             mapping=aes(x=Dim.1,
                         y=Dim.2,
                         fill=coul_16[category_mds_cos$group]),
             fill=coul_16[category_mds_cos$group],
             shape=24,
             size=10, 
             stroke = 2)+
  labs(title = "Description embeddings, grouped by mode",
       subtitle = "MDS based on cosine dissimilarity")+
  coord_cartesian(xlim =c(-0.7,-0.5), ylim = c(-0.25, 0.25))+
  theme(legend.position = c(0.85, 0.1),
        plot.margin = unit(c(1, 1, 1, 1), "cm"))  
dev.off()

# description embeddings by mode, MDS based on euclidean distance
png("plots/embeddings_mds_eucl_descriptions_mode.png", 1400, 1400, type = 'cairo')
ggscatter(
     descr_mds_eucl, x="Dim.1", y="Dim.2",
     palette = c(coul[2],coul[1]),
     ellipse = TRUE,
     size = 4,  
     legend = "bottomright", 
     ggtheme = theme_bw(),
     color = "type",
     alpha=0.75,
     font.tickslab = c(axisLabelSize*12, "plain"),
     font.x = c(axisLabelSize*16, "plain"),
     font.y = c(axisLabelSize*16, "plain"),
     font.title = c(titleSize*22, "bold"),
     font.subtitle = c(titleSize*14, "plain"),
     font.legend = c(axisLabelSize*16, "plain"),
     cex.main = titleSize
) + stat_mean(aes(fill=type),
     size=10,
     shape=21, 
     stroke = 1,
     color="black",
     alpha=0.5) + 
  geom_point(category_mds_eucl,
             mapping=aes(x=Dim.1,
                         y=Dim.2,
                         fill=coul_16[category_mds_eucl$group]),
             fill=coul_16[category_mds_eucl$group],
             shape=24,
             size=10, 
             stroke = 2)+
  labs(title = "Description embeddings, grouped by mode",
       subtitle = "MDS based on euclidean distance")+
  coord_cartesian(xlim =c(-11,-6), ylim = c(-1, 1))+
  theme(legend.position = c(0.85, 0.1),
        plot.margin = unit(c(1, 1, 1, 1), "cm"))  
dev.off()


# description embeddings by category, MDS based on cosine dissimilarity
png("plots/embeddings_mds_cos_descriptions_category.png", 1400, 1400, type = 'cairo')
ggscatter(
     descr_mds_cos, x="Dim.1", y="Dim.2",
     palette = coul_16,
     ellipse = TRUE,
     size = 4,  
     legend = "right", 
     ggtheme = theme_bw(),
     color = "category",
     alpha=0.75,
     font.tickslab = c(axisLabelSize*12, "plain"),
     font.x = c(axisLabelSize*16, "plain"),
     font.y = c(axisLabelSize*16, "plain"),
     font.title = c(titleSize*22, "bold"),
     font.subtitle = c(titleSize*14, "plain"),
     font.legend = c(axisLabelSize*16, "plain"),
     cex.main = titleSize
) + stat_mean(aes(fill=category),
     size=10,
     shape=21, 
     stroke = 1,
     color="black",
     alpha=0.5) + 
  geom_point(category_mds_cos,
             mapping=aes(x=Dim.1,
                         y=Dim.2,
                         fill=coul_16[category_mds_cos$group]),
             fill=coul_16[category_mds_cos$group],
             shape=24,
             size=10, 
             stroke = 2)+
  labs(title = "Description embeddings, grouped by category",
       subtitle = "MDS based on cosine dissimilarity")+
  coord_cartesian(xlim =c(-0.7,-0.5), ylim = c(-0.25, 0.25))+
  theme(legend.position = c(0.85, 0.5),
        plot.margin = unit(c(1, 1, 1, 1), "cm"))  
dev.off()

# description embeddings by category, MDS based on euclidean distance
png("plots/embeddings_mds_eucl_descriptions_category.png", 1400, 1400, type = 'cairo')
ggscatter(
     descr_mds_eucl, x="Dim.1", y="Dim.2",
     palette = coul_16,
     ellipse = TRUE,
     size = 4,  
     legend = "right", 
     ggtheme = theme_bw(),
     color = "category",
     alpha=0.75,
     font.tickslab = c(axisLabelSize*12, "plain"),
     font.x = c(axisLabelSize*16, "plain"),
     font.y = c(axisLabelSize*16, "plain"),
     font.title = c(titleSize*22, "bold"),
     font.subtitle = c(titleSize*14, "plain"),
     font.legend = c(axisLabelSize*16, "plain"),
     cex.main = titleSize
) + stat_mean(aes(fill=category),
     size=10,
     shape=21, 
     stroke = 1,
     color="black",
     alpha=0.5) + 
  geom_point(category_mds_eucl,
             mapping=aes(x=Dim.1,
                         y=Dim.2,
                         fill=coul_16[category_mds_eucl$group]),
             fill=coul_16[category_mds_eucl$group],
             shape=24,
             size=10, 
             stroke = 2)+
  labs(title = "Description embeddings, grouped by category",
       subtitle = "MDS based on euclidean distance")+
  coord_cartesian(xlim =c(-11,-6), ylim = c(-1, 1))+
  theme(legend.position = c(0.85, 0.5),
        plot.margin = unit(c(1, 1, 1, 1), "cm"))  
dev.off()

```
Plot image embeddings:
```{r}
# image embeddings by category, MDS based on cosine dissimilarity
png("plots/embeddings_mds_cos_images.png", 1400, 1400, type = 'cairo')
ggscatter(
     image_mds_cos, x="Dim.1", y="Dim.2",
     palette = coul_16,
     ellipse = TRUE,
     size = 4,  
     legend = "topleft", 
     ggtheme = theme_bw(),
     color = "category",
     alpha=0.75,
     font.tickslab = c(axisLabelSize*12, "plain"),
     font.x = c(axisLabelSize*16, "plain"),
     font.y = c(axisLabelSize*16, "plain"),
     font.title = c(titleSize*22, "bold"),
     font.subtitle = c(titleSize*14, "plain"),
     font.legend = c(axisLabelSize*16, "plain"),
     cex.main = titleSize
) + stat_mean(aes(fill=category),
     size=10,
     shape=21, 
     stroke = 1,
     color="black",
     alpha=0.5) +
  labs(title = "Image embeddings, grouped by category",
       subtitle = "MDS based on cosine dissimilarity matrix")+
  theme(legend.position = c(0.1, 0.5),
        plot.margin = unit(c(1, 1, 1, 1), "cm"))  
dev.off()

# image embeddings by category, MDS based on euclidean distance
png("plots/embeddings_mds_eucl_images.png", 1400, 1400, type = 'cairo')
ggscatter(
     image_mds_eucl, x="Dim.1", y="Dim.2",
     palette = coul_16,
     ellipse = TRUE,
     size = 4,  
     legend = "topleft", 
     ggtheme = theme_bw(),
     color = "category",
     alpha=0.75,
     font.tickslab = c(axisLabelSize*12, "plain"),
     font.x = c(axisLabelSize*16, "plain"),
     font.y = c(axisLabelSize*16, "plain"),
     font.title = c(titleSize*22, "bold"),
     font.subtitle = c(titleSize*14, "plain"),
     font.legend = c(axisLabelSize*16, "plain"),
     cex.main = titleSize
) + stat_mean(aes(fill=category),
     size=10,
     shape=21, 
     stroke = 1,
     color="black",
     alpha=0.5) +
  labs(title = "Image embeddings, grouped by category",
       subtitle = "MDS based on euclidean distance matrix")+
  theme(legend.position = c(0.1, 0.5),
        plot.margin = unit(c(1, 1, 1, 1), "cm"))  
dev.off()

```

Plot all embeddings (categories, descriptions, images):
```{r}
# Sort embeddings by type to ensure that categories are plotted after descriptions.
total_mds_cos <- total_mds_cos[order(total_mds_cos$type, decreasing = TRUE),]
total_mds_eucl <- total_mds_eucl[order(total_mds_eucl$type, decreasing = TRUE),]

# all embeddings by category, MDS based on cosine dissimilarity
png("plots/embeddings_mds_cos_all_category.png", 1400, 1400, type = 'cairo')
ggscatter(
     total_mds_cos, x="Dim.1", y="Dim.2",
     palette = coul_16,
     size = 4,  
     legend = "topleft", 
     ggtheme = theme_bw(),
     color = "category",
     shape ="type",
     alpha=0.75,
     font.tickslab = c(axisLabelSize*12, "plain"),
     font.x = c(axisLabelSize*16, "plain"),
     font.y = c(axisLabelSize*16, "plain"),
     font.title = c(titleSize*22, "bold"),
     font.subtitle = c(titleSize*14, "plain"),
     font.legend = c(axisLabelSize*16, "plain"),
     cex.main = titleSize
) + stat_mean(aes(fill=category),
     size=10,
     shape=21, 
     stroke = 1,
     color="black",
     alpha=0.5) +
  labs(title = "All embeddings, grouped by category",
       subtitle = "MDS based on cosine dissimilarity matrix")+
  theme(legend.position = c(0.5, 0.5),
        plot.margin = unit(c(1, 1, 1, 1), "cm"))  
dev.off()

# all embeddings by category, MDS based on euclidean distance
png("plots/embeddings_mds_eucl_all_category.png", 1400, 1400, type = 'cairo')
ggscatter(
     total_mds_eucl, x="Dim.1", y="Dim.2",
     palette = coul_16,
     size = 4,  
     legend = "bottom", 
     ggtheme = theme_bw(),
     color = "category",
     shape ="type",
     alpha = 0.75,
     font.tickslab = c(axisLabelSize*12, "plain"),
     font.x = c(axisLabelSize*16, "plain"),
     font.y = c(axisLabelSize*16, "plain"),
     font.title = c(titleSize*22, "bold"),
     font.subtitle = c(titleSize*14, "plain"),
     font.legend = c(axisLabelSize*16, "plain"),
     cex.main = titleSize
) + stat_mean(aes(fill=category),
     size=10,
     shape=21, 
     stroke = 1,
     color="black",
     alpha=0.5) +
  labs(title = "All embeddings, grouped by category",
       subtitle = "MDS based on euclidean distance matrix")+
  theme(legend.position = c(0.5, 0.5),
        plot.margin = unit(c(1, 1, 1, 1), "cm"))  
dev.off()

# all embeddings by type, MDS based on cosine dissimilarity
png("plots/embeddings_mds_cos_all_type.png", 1400, 1400, type = 'cairo')
ggscatter(
     total_mds_cos, x="Dim.1", y="Dim.2",
     palette = coul_16,
     size = 4,  
     legend = "topleft", 
     ggtheme = theme_bw(),
     color = "type",
     font.tickslab = c(axisLabelSize*12, "plain"),
     font.x = c(axisLabelSize*16, "plain"),
     font.y = c(axisLabelSize*16, "plain"),
     font.title = c(titleSize*22, "bold"),
     font.subtitle = c(titleSize*14, "plain"),
     font.legend = c(axisLabelSize*16, "plain"),
     cex.main = titleSize
) +
  labs(title = "All embeddings, grouped by category",
       subtitle = "MDS based on cosine dissimilarity matrix")+
  theme(legend.position = c(0.5, 0.5),
        plot.margin = unit(c(1, 1, 1, 1), "cm"))  
dev.off()

# all embeddings by category, MDS based on euclidean distance
png("plots/embeddings_mds_eucl_all_type.png", 1400, 1400, type = 'cairo')
ggscatter(
     total_mds_eucl, x="Dim.1", y="Dim.2",
     palette = coul_16,
     size = 4,  
     legend = "bottom", 
     ggtheme = theme_bw(),
     color = "type",
     font.tickslab = c(axisLabelSize*12, "plain"),
     font.x = c(axisLabelSize*16, "plain"),
     font.y = c(axisLabelSize*16, "plain"),
     font.title = c(titleSize*22, "bold"),
     font.subtitle = c(titleSize*14, "plain"),
     font.legend = c(axisLabelSize*16, "plain"),
     cex.main = titleSize
) +
  labs(title = "All embeddings, grouped by type",
       subtitle = "MDS based on euclidean distance matrix")+
  theme(legend.position = c(0.5, 0.5),
        plot.margin = unit(c(1, 1, 1, 1), "cm"))  
dev.off()

```

```{r}
library(cluster)
desc_embeddings <- rbind(literal_embeddings,sentimental_embeddings)

total_clust <- kmeans(embeddings, 2)
desc_clust <- kmeans(desc_embeddings, 2)
image_clust <- kmeans(image_embeddings, 15)

png("plots/embeddings_pca_all.png", 1000, 1000, type = 'cairo')
par(mar=c(14, 10, 8, 4) + 0.1)
clusplot(embeddings, 
         total_clust$cluster, 
         stand = TRUE, 
         main = "all embeddings, 2 clusters", 
         lines = 0, 
         col.p = coul[total_clust$cluster],
         col.clus = coul[3],
         las=1,
         xlab=NA,
         ylab=NA,
         cex.axis = axisLabelSize,
         cex.main = titleSize,
         cex.lab = labelSize,
         sub="")

title(xlab = "Component 1", cex.lab = labelSize, line = 6)
title(xlab = "These two components explain 15.17% of the point variability.", cex.lab = 0.75*labelSize, line = 10)
title(ylab = "Component 2", cex.lab = labelSize, line = 4)
dev.off()

png("plots/embeddings_pca_image.png", 1000, 1000, type = 'cairo')
par(mar=c(14, 10, 8, 4) + 0.1)
clusplot(image_embeddings, 
         image_clust$cluster, 
         stand = TRUE, 
         main = "image embeddings, 15 clusters", 
         lines = 0, 
         col.p = coul_16[image_clust$cluster], 
         col.clus = coul[3],
         las=1,
         xlab=NA,
         ylab=NA,
         cex.axis = axisLabelSize,
         cex.main = titleSize,
         cex.lab = labelSize,
         sub="")

title(xlab = "Component 1", cex.lab = labelSize, line = 6)
title(xlab = "These two components explain 12.93% of the point variability.", cex.lab = 0.75*labelSize, line = 10)
title(ylab = "Component 2", cex.lab = labelSize, line = 4)
dev.off()

png("plots/embeddings_pca_descriptions.png", 1000, 1000, type = 'cairo')
par(mar=c(14, 10, 8, 4) + 0.1)
clusplot(desc_embeddings, 
         desc_clust$cluster, 
         stand = TRUE, 
         main = "description embeddings, 2 clusters", 
         lines = 0, 
         col.p = coul_16[desc_clust$cluster], 
         col.clus = coul[3],
         las=1,
         xlab=NA,
         ylab=NA,
         cex.axis = axisLabelSize,
         cex.main = titleSize,
         cex.lab = labelSize,
         sub="")

title(xlab = "Component 1", cex.lab = labelSize, line = 6)
title(xlab = "These two components explain 16.26% of the point variability.", cex.lab = 0.75*labelSize, line = 10)
title(ylab = "Component 2", cex.lab = labelSize, line = 4)
dev.off()

```

```{r}
library(lsa)
# This function assumes the two dataframes to have the same number of rows and identical row names. Therefore, it is tailored towards the difference between literal and sentimental descriptions -don't use this universally.
semantic_sim <- function(df1, df2){
  result = data.frame(matrix(ncol = 5, nrow = 0))
  colnames(result) <- c("category", "model", "description", "cos_sim", "eucl_dist")
  for(row in 1:nrow(df1)){
    meta =  strsplit(rownames(literal_embeddings[row, ]), split="_")
    id  =  strsplit(meta[[1]][1], split="-")
    result[row,]$category <- id[[1]][1]
    result[row,]$model <- id[[1]][2]
    result[row,]$description <- meta[[1]][3]
    result[row,]$cos_sim <- cosine(as.numeric(df1[row,]), as.numeric(df2[row,]))
    result[row,]$eucl_dist <- sqrt(sum((as.numeric(df1[row,]) - as.numeric(df2[row,]))^2))
  }
  return(result)
}

sim <- semantic_sim(literal_embeddings, sentimental_embeddings)
```

```{r}
png("plots/cosSim_literal_vs_sentimental.png", 1000, 1000, type = 'cairo')
par(mar=c(18, 12, 12, 4) + 0.1)
boxplot(sim$cos_sim ~ sim$category,
        col=coul_16,
        border=coul_16_Bord,
        main="cosine similarity \nbetween literal and sentimental descriptions",
        xlab=NA,
        ylab=NA,
        las=2,
        cex.axis = axisLabelSize,
        cex.main = titleSize,
        cex.lab = labelSize)

title(xlab = "furnishing category", cex.lab = labelSize, line = 14)
title(ylab = "cosine similarity", cex.lab = labelSize, line = 6)
dev.off()

png("plots/euclDist_literal_vs_sentimental.png", 1000, 1000, type = 'cairo')
par(mar=c(18, 12, 12, 4) + 0.1)
boxplot(sim$eucl_dist ~ sim$category,
        col=coul_16,
        border=coul_16_Bord,
        main="euclidean distance \nbetween literal and sentimental descriptions",
        xlab=NA,
        ylab=NA,
        las=2,
        cex.axis = axisLabelSize,
        cex.main = titleSize,
        cex.lab = labelSize)

title(xlab = "furnishing category", cex.lab = labelSize, line = 14)
title(ylab = "euclidean distance", cex.lab = labelSize, line = 6)
dev.off()
```
```{r}
cos_stats <- data.frame(matrix(ncol = 7, nrow = 0))
eucl_stats <- data.frame(matrix(ncol = 7, nrow = 0))

for(cat in categories){
  sum_cos <- data.frame(as.list(summary(sim$cos_sim[sim$category==cat])))
  cos_stats <- rbind(cos_stats, sum_cos)
  
  sum_eucl <- data.frame(as.list(summary(sim$eucl_dist[sim$category==cat])))
  eucl_stats <- rbind(eucl_stats, sum_eucl)
}

sum_total_cos <- data.frame(as.list(summary(sim$cos_sim)))
cos_stats <- rbind(cos_stats, sum_total_cos)

sum_total_eucl <- data.frame(as.list(summary(sim$eucl_dist)))
eucl_stats <- rbind(eucl_stats, sum_total_eucl)

rownames(cos_stats) <- c(categories, "total")
rownames(eucl_stats) <- c(categories, "total")

write.csv(cos_stats,"cosSim_literal_vs_sentimental.csv", row.names=TRUE)
write.csv(eucl_stats,"euclDist_literal_vs_sentimental.csv", row.names=TRUE)
```


